package api; 

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

import api.User;
import api.UserRepository;
import api.Book;
import api.BookRepository;
import api.Book_DistanceComp;

import java.util.*;
import java.lang.Math;

@Controller    // This means that this class is a Controller
@RequestMapping(path="/demo") // This means URL's start with /demo (after Application path)
public class MainController {
	@Autowired // This means to get the bean called userRepository
	           // Which is auto-generated by Spring, we will use it to handle the data
	private UserRepository userRepository;
	@Autowired
	private BookRepository bookRepository;

	//Invoke upon "Sign Up", return JSON String
    //Input: username, password
    //Output: If success, new User class in JSON. If fail, empty User class in JSON
    //FAIL CASE: The new User's username already existed in the database
	@GetMapping(path="/addUser")
	public @ResponseBody String addNewUser (@RequestParam String username
			, @RequestParam String password, @RequestParam double longitude
			, @RequestParam double latitude) {
		// @ResponseBody means the returned String is the response, not a view name
		// @RequestParam means it is a parameter from the GET or POST request
		User userToAdd = new User();
		userToAdd.setUsername(username);
		userToAdd.setPassword(password);
		userToAdd.setLongitude(longitude);
		userToAdd.setLatitude(latitude);
		userRepository.save(userToAdd);
		return "Saved new user: " + username + "\n";
	}
	
	@GetMapping(path="/addBook") 
	public @ResponseBody String addNewBook (@RequestParam int ownerID
			, @RequestParam String author, @RequestParam int rating, @RequestParam String title
			, @RequestParam String picture, @RequestParam double longitude, @RequestParam double latitude) {

		Book bookToAdd = new Book();
		bookToAdd.setOwnerID(ownerID);
		bookToAdd.setAuthor(author);
		bookToAdd.setRating(rating);
		bookToAdd.setTitle(title);
		bookToAdd.setPicture(picture);
		bookToAdd.setLongitude(longitude);
		bookToAdd.setLatitude(latitude);
		bookRepository.save(bookToAdd);
		return "Saved new book: " + title + "\n";
	}

	@GetMapping(path="/allUsers")
	public @ResponseBody Iterable<User> getAllUsers() {

		return userRepository.findAll();
	}
	
	@GetMapping(path="/allBooks")
	public @ResponseBody Iterable<Book> getAllBooks() {
		
		return bookRepository.findAll() == null ? null : bookRepository.findAll();
	}
	
	@GetMapping(path="/getUser")
	public @ResponseBody User getUser(@RequestParam String username, @RequestParam String password) {
		return userRepository.findByUsernameAndPassword(username, password);
	}
	
	//Invoke upon "Login", return a jsonfied user class if success		
		//Input: username, password
		//Output: If Success, return the whole User class in JSON. If fail, return empty User class in JSON
		//FAIL CASE: username doesn't exist OR password doesn't match with the username.
	@GetMapping(path="/verifyUser")
	public @ResponseBody User verifyUser(@RequestParam String username, @RequestParam String password
		, @RequestParam double longitude, @RequestParam double latitude) {
		User userToVerify = userRepository.findByUsernameAndPassword(username, password);
		if(userToVerify != null) {
			userToVerify.setLongitude(longitude);
			userToVerify.setLatitude(latitude);
			userRepository.save(userToVerify);
		}
		return userToVerify;
	}
	
	@GetMapping(path="/updateUserBookLocations")
	public @ResponseBody String updateUserBookLocations(@RequestParam int userID
	, @RequestParam double longitude, @RequestParam double latitude) {
		Iterable<Book> userBooksIterable = bookRepository.findByOwnerID(userID);
		
		List<Book> userBooks = new ArrayList<Book>();
		userBooksIterable.forEach(userBooks::add);
		
		for(Book book : userBooks) {
			if(book.getOwnerID() == userID) {
				book.setLatitude(latitude);
				book.setLongitude(longitude);
				bookRepository.save(book);
			}
		}
		if(userBooks.size() > 0) {
			return userBooks.size() + " book(s) updated for userID: " + userID + "\n";
		}
		else {
			return "No books found for specified user ID\n";
		}

	}
	
	//Invoke upon "Search Users", return a jsonfied user list for front end.
	//Input: the Name typed by the user.
	//Output: If success, return all the users in JSON. If fail, return empty user list in JSON		
	//FAIL CASE: No instances of such a Name in userTable.
	@GetMapping(path="/searchUsers")
	public @ResponseBody Iterable<User> searchUsers(@RequestParam String name) {
		return userRepository.findByName(name);
	}
	
	@GetMapping(path="/updateUser")
	public @ResponseBody String updateUser(@RequestParam int userID, @RequestParam String password
		, @RequestParam String name, @RequestParam String picture) {
		User userToUpdate = userRepository.findByUserID(userID);
		if(userToUpdate == null) {
			return "User: " + userID + " not found \n";
		}
		if(userToUpdate.getPassword().equals(password)) {
			userToUpdate.setName(name);
			userToUpdate.setPicture(picture);
			userRepository.save(userToUpdate);
			return "User: " + userID + " updated \n";
		}
		else {
			return "Invalid password for user: " + userID + "\n";
		}
	}
	
	@GetMapping(path="/getUserBookList")
	public @ResponseBody Iterable<Book> getUserBookList(@RequestParam int ownerID) {
		return bookRepository.findByOwnerID(ownerID);
	}
	
	
	//Invoke upon "Search Books", return a jsonfied booklist for front end.
	//Input: the bookName typed by the user.
	//Output: If success, return all the books in JSON. If fail, return empty booklist in JSON
	//FAIL CASE: No instances of such a bookName in bookTable.
	@GetMapping(path="/searchBooks")
	public @ResponseBody Iterable<Book> searchBooks(@RequestParam String title, @RequestParam int userID) {
		Iterable<Book> matchedBooksIterable = bookRepository.findByTitle(title);
		User userSearching = userRepository.findByUserID(userID);
		double latitude = userSearching.getLatitude();
		double longitude = userSearching.getLongitude();
		List<Book> matchedBooks = new ArrayList<Book>();
		matchedBooksIterable.forEach(matchedBooks::add);
		for(Book book : matchedBooks)  {
			double distance = getDistance(latitude, longitude, book.getLatitude(), book.getLongitude(), "M");
			book.setDistance(distance);
		}
		Collections.sort(matchedBooks, new Book_DistanceComp());
		return matchedBooks;
	}
	
	//Invoke upon "Edit book"
	//Input: All information of a book.
	//Output:void
	//FAIL CASE: None
	@GetMapping(path="/updateBook")
	public @ResponseBody String updateBook(@RequestParam int bookID, @RequestParam int ownerID
		, @RequestParam String title, @RequestParam String author, @RequestParam String picture
		, @RequestParam int rating) {
		Book bookToUpdate = bookRepository.findByBookID(bookID);
		if(bookToUpdate != null) {
			bookToUpdate.setTitle(title);
			bookToUpdate.setAuthor(author);
			bookToUpdate.setPicture(picture);
			bookToUpdate.setRating(rating);
			bookRepository.save(bookToUpdate);
			return "Book: " + bookID + " updated";
		}
		else {
			return "Book: " + bookID + " not found";
		}
		
	}
	
	//input: bookID
	//output: none
	//remove book from database
	@GetMapping(path="/deleteBook")
	public @ResponseBody boolean  deleteBook(@RequestParam int bookID) {
		Book bookToDelete = bookRepository.findByBookID(bookID);
		if(bookToDelete != null) {
			bookRepository.delete(bookToDelete);		
			return true; 
		}
		return false; 
	
	}
	
	//Input: userID
	//Output: JSON String of booklist, sorted in distance
	@GetMapping(path="/getNearbyBooks")
	public @ResponseBody Iterable<Book> getNearbyBooks(@RequestParam int userID) {
		Iterable<Book> allBooksIterable = bookRepository.findAll();
		List<Book> allBooks = new ArrayList<Book>();
		allBooksIterable.forEach(allBooks::add);
		User userSearching = userRepository.findByUserID(userID);
		if(userSearching == null) {
			return allBooks;
		}
		
		double latitude = userSearching.getLatitude();
		double longitude = userSearching.getLongitude();

		for(Book book: allBooks) {
			double bookLatitude = book.getLatitude();
			double bookLongitude = book.getLongitude();
			double distance = getDistance(latitude, longitude, bookLatitude, bookLongitude, "M");
			book.setDistance(distance);
		}
		
		Collections.sort(allBooks, new Book_DistanceComp());
		
		return allBooks;
	}
	

	private static double getDistance(double lat1, double lon1, double lat2, double lon2, String unit) {
		double theta = lon1 - lon2;
		double dist = Math.sin(deg2rad(lat1)) * Math.sin(deg2rad(lat2)) + Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * Math.cos(deg2rad(theta));
		dist = Math.acos(dist);
		dist = rad2deg(dist);
		dist = dist * 60 * 1.1515;
		if (unit == "K") {
			dist = dist * 1.609344;
		 } 
		else if (unit == "N") {
			dist = dist * 0.8684;
		}
		return (dist);
	}

	private static double deg2rad(double deg) {
		return (deg * Math.PI / 180.0);
	}

	private static double rad2deg(double rad) {
		return (rad * 180.0 / Math.PI);
	}
	
}
